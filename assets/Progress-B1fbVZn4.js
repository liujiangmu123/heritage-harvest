import{R as a}from"./index-CCr_emsx.js";import{Q as i}from"./three.module-C2hvsvVY.js";const b=t=>{let e;const s=new Set,r=(n,S)=>{const o=typeof n=="function"?n(e):n;if(!Object.is(o,e)){const m=e;e=S??(typeof o!="object"||o===null)?o:Object.assign({},e,o),s.forEach(p=>p(e,m))}},u=()=>e,g={setState:r,getState:u,getInitialState:()=>f,subscribe:n=>(s.add(n),()=>s.delete(n))},f=e=t(r,u,g);return g},v=t=>t?b(t):b,d=t=>t;function I(t,e=d){const s=a.useSyncExternalStore(t.subscribe,a.useCallback(()=>e(t.getState()),[t,e]),a.useCallback(()=>e(t.getInitialState()),[t,e]));return a.useDebugValue(s),s}const l=t=>{const e=v(t),s=r=>I(e,r);return Object.assign(s,e),s},j=t=>t?l(t):l;let c=0;const O=j(t=>(i.onStart=(e,s,r)=>{t({active:!0,item:e,loaded:s,total:r,progress:(s-c)/(r-c)*100})},i.onLoad=()=>{t({active:!1})},i.onError=e=>t(s=>({errors:[...s.errors,e]})),i.onProgress=(e,s,r)=>{s===r&&(c=r),t({active:!0,item:e,loaded:s,total:r,progress:(s-c)/(r-c)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));export{O as u};
